// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Utils = require("../../utils/Utils.bs.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var HashHelper = require("./HashHelper.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var BitcoinjsLib = require("bitcoinjs-lib");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");
var JsonStableStringify = require("json-stable-stringify");

function Make(funarg) {
  var make = function (param) {
    return /* array */[];
  };
  var makeItemHash = function (issuerPubKey, $$event) {
    var issuerPubKeyHash = BitcoinjsLib.crypto.sha256(issuerPubKey);
    var eventHash = BitcoinjsLib.crypto.sha256(JsonStableStringify(HashHelper.pruneNullFields(Curry._1(funarg[/* encode */0], $$event))));
    return BitcoinjsLib.crypto.sha256(Buffer.concat(/* array */[
                    issuerPubKeyHash,
                    eventHash
                  ]));
  };
  var items = function (log) {
    return log;
  };
  var makeItem = function (issuerKeyPair, $$event) {
    var issuerPubKey = Utils.publicKeyFromKeyPair(issuerKeyPair);
    var hashBuffer = makeItemHash(issuerPubKey, $$event);
    return /* record */[
            /* event */$$event,
            /* hash */Utils.bufToHex(hashBuffer),
            /* issuerPubKey */issuerPubKey,
            /* signature */issuerKeyPair.sign(hashBuffer)
          ];
  };
  var append = function (issuer, $$event, log) {
    var item = makeItem(issuer, $$event);
    return /* tuple */[
            item,
            $$Array.append(log, /* array */[item])
          ];
  };
  var appendItem = function (item, log) {
    return $$Array.append(log, /* array */[item]);
  };
  var appendItems = function (items, log) {
    return $$Array.append(log, items);
  };
  var reduce = $$Array.fold_left;
  var findNewItems = function (other, log) {
    var existingHashes = Belt_SetString.fromArray($$Array.map((function (param) {
                return param[/* hash */1];
              }), log));
    return Belt_Array.keepMapU($$Array.fold_left((function (found, item) {
                      var hash = item[/* hash */1];
                      if (Js_option.isSome(Caml_option.undefined_to_opt(found.find((function (param) {
                                        return param[0] === hash;
                                      })))) || Belt_SetString.has(existingHashes, hash)) {
                        return found;
                      } else {
                        return $$Array.append(found, /* array */[/* tuple */[
                                      hash,
                                      item
                                    ]]);
                      }
                    }), /* array */[], other), (function (param) {
                  var item = param[1];
                  var issuerPubKey = item[/* issuerPubKey */2];
                  var hashCheck = makeItemHash(issuerPubKey, item[/* event */0]);
                  if (Utils.bufToHex(hashCheck) !== item[/* hash */1] || !Utils.keyFromPublicKey(BitcoinjsLib.networks.bitcoin, issuerPubKey).verify(hashCheck, item[/* signature */3])) {
                    return undefined;
                  } else {
                    return item;
                  }
                }));
  };
  var length = function (prim) {
    return prim.length;
  };
  var getSummary = function (log) {
    return /* record */[/* knownItems */Belt_SetString.fromArray($$Array.map((function (param) {
                        return param[/* hash */1];
                      }), log))];
  };
  var encodeSummary = function (summary) {
    return Json_encode.object_(/* :: */[
                /* tuple */[
                  "knownItems",
                  Json_encode.array((function (prim) {
                          return prim;
                        }), Belt_SetString.toArray(summary[/* knownItems */0]))
                ],
                /* [] */0
              ]);
  };
  var decodeSummary = function (raw) {
    return /* record */[/* knownItems */Belt_SetString.fromArray(Json_decode.field("knownItems", (function (param) {
                        return Json_decode.array(Json_decode.string, param);
                      }), raw))];
  };
  var item = function (item$1) {
    return Json_encode.object_(/* :: */[
                /* tuple */[
                  "event",
                  Curry._1(funarg[/* encode */0], item$1[/* event */0])
                ],
                /* :: */[
                  /* tuple */[
                    "issuerPubKey",
                    item$1[/* issuerPubKey */2]
                  ],
                  /* :: */[
                    /* tuple */[
                      "hash",
                      item$1[/* hash */1]
                    ],
                    /* :: */[
                      /* tuple */[
                        "signature",
                        Utils.signatureToDER(item$1[/* signature */3])
                      ],
                      /* [] */0
                    ]
                  ]
                ]
              ]);
  };
  var log = function (log$1) {
    return Json_encode.object_(/* :: */[
                /* tuple */[
                  "items",
                  Json_encode.array(item, log$1)
                ],
                /* [] */0
              ]);
  };
  var ecSig = function (ecSig$1) {
    return Utils.signatureFromDER(Json_decode.string(ecSig$1));
  };
  var item$1 = function (item$2) {
    return /* record */[
            /* event */Json_decode.field("event", funarg[/* decode */1], item$2),
            /* hash */Json_decode.field("hash", Json_decode.string, item$2),
            /* issuerPubKey */Json_decode.field("issuerPubKey", Json_decode.string, item$2),
            /* signature */Json_decode.field("signature", ecSig, item$2)
          ];
  };
  var log$1 = function (param) {
    return Json_decode.field("items", (function (param) {
                  return Json_decode.array(item$1, param);
                }), param);
  };
  return [
          make,
          items,
          append,
          appendItem,
          appendItems,
          reduce,
          findNewItems,
          length,
          log,
          log$1,
          item,
          item$1,
          getSummary,
          encodeSummary,
          decodeSummary
        ];
}

exports.Make = Make;
/* Utils Not a pure module */
